<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accident Detection</title>
    <!-- Add Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Add UUID library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-image: url('https://img.freepik.com/free-vector/choose-right-way-realistic-concept_1284-5715.jpg?t=st=1740466694~exp=1740470294~hmac=0db0f3fabde02c394cd6be16ee2763b0ac84ad7382088910ec42d1ffb428c6f5&w=996');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            box-sizing: border-box;
        }
        .container {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
            width: 600px;
            max-width: 90%;
            margin: 20px auto;
            max-height: none;
            overflow-y: visible;
        }
        label, input, select, button {
            display: block;
            margin: 10px auto;
            width: 90%;
        }
        button {
            background-color: #007BFF;
            color: white;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px auto;
        }
        button:hover { background-color: #0056b3; }
        #detectedFrames img {
            margin: 10px;
            max-width: 100%;
            height: auto;
            border: 3px solid #007BFF;
        }
        #webcamContainer {
            margin: 20px auto;
            width: 90%;
            display: none;
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
        }
        #webcamVideo {
            width: 100%;
            border-radius: 8px;
            margin-bottom: 10px;
            max-height: 400px;
            object-fit: contain;
        }
        #liveDetection {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
        }
        .recording-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: red;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }
        .input-mode {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .input-mode button {
            width: auto;
            padding: 10px 20px;
        }
        .active {
            background-color: #28a745;
        }
        #timer {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
            color: #007BFF;
        }
        #processingStatus {
            margin: 10px 0;
            font-weight: bold;
            color: #dc3545;
        }
        .location-controls {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #f9f9f9;
        }
        .location-controls button {
            width: auto;
            display: inline-block;
            margin: 5px;
            padding: 5px 15px;
        }
        .location-error {
            color: #dc3545;
            margin: 5px 0;
            font-size: 0.9em;
        }
        #cameraSelect {
            width: 90%;
            padding: 10px;
            margin: 10px auto;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            font-size: 14px;
            display: block;
        }
        .webcam-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
            opacity: 0.9;
            transition: opacity 0.3s;
        }
        .webcam-controls button {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin: 0;
            width: auto;
        }
        .webcam-controls button:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }
        .fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7) !important;
            color: white;
            border: 2px solid white !important;
            width: 40px !important;
            height: 40px !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            padding: 0 !important;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        .fullscreen-btn:hover {
            background: rgba(0, 0, 0, 0.9) !important;
            transform: scale(1.1);
        }
        .fullscreen-btn i {
            font-size: 16px;
        }
        /* Show different icons based on fullscreen state */
        .fullscreen-btn .fa-expand {
            display: inline-block;
        }
        .fullscreen-btn .fa-compress {
            display: none;
        }
        #webcamContainer.fullscreen .fullscreen-btn .fa-expand {
            display: none;
        }
        #webcamContainer.fullscreen .fullscreen-btn .fa-compress {
            display: inline-block;
        }
        #webcamContainer.fullscreen {
            width: 100% !important;
            height: 100% !important;
            margin: 0 !important;
            position: fixed !important;
            top: 0;
            left: 0;
            z-index: 9999;
            background: #000;
        }
        #webcamContainer.fullscreen #webcamVideo {
            width: 100%;
            height: 100%;
            object-fit: contain;
            max-height: 100vh;
        }
        #webcamContainer:hover .webcam-controls,
        #webcamContainer:hover .fullscreen-btn {
            opacity: 1;
        }
        #webcamContainer .webcam-controls,
        #webcamContainer .fullscreen-btn {
            opacity: 0;
        }
        /* Update best frames container styles for better mobile display */
        .best-frames-container {
            margin: 20px auto;
            padding: 15px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 600px;
        }

        .best-frames-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        /* Mobile responsive grid */
        @media (max-width: 768px) {
            .best-frames-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .best-frames-container {
                padding: 10px;
                margin: 10px auto;
            }
        }

        .frame-card {
            position: relative;
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
            aspect-ratio: 16/9;
            display: flex;
            flex-direction: column;
        }

        .frame-card:hover {
            transform: scale(1.02);
        }

        .frame-card img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 4px;
        }

        .frame-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            z-index: 1;
        }

        .frame-rank {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #007bff;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 1;
        }

        .frames-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 0 10px;
        }

        .frames-title h3 {
            margin: 0;
            color: #333;
            font-size: 1.2em;
        }

        .no-frames-message {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .frame-info {
                font-size: 0.8em;
                padding: 4px 8px;
            }

            .frame-rank {
                width: 20px;
                height: 20px;
                font-size: 0.8em;
            }

            .frames-title h3 {
                font-size: 1em;
            }

            .frame-card {
                aspect-ratio: 16/9;
            }
        }

        .upload-info {
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: bold;
            background-color: #f8f9fa;
            color: #666;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .upload-info.uploading {
            background-color: #fff3cd;
            color: #856404;
        }

        .upload-info.success {
            background-color: #d4edda;
            color: #155724;
        }

        .upload-info.error {
            background-color: #f8d7da;
            color: #721c24;
        }

        .upload-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            animation: spin 0.75s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .uploading .upload-spinner {
            display: inline-block;
        }

        /* Update result element styles */
        #result {
            margin: 15px 0;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
        }

        #result .upload-spinner {
            margin-right: 10px;
        }

        .processing-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            background-color: #fff3cd;
            color: #856404;
            font-weight: 500;
            text-align: center;
        }

        .processing-status .upload-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            animation: spin 0.75s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
        }

        .upload-button-content {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        .processing-status.animated {
            animation: fadeInOut 2s ease-in-out infinite;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Accident Detection</h1>
    
    <div class="input-mode">
        <button id="fileMode" class="active">File Upload Mode</button>
        <button id="webcamMode">Webcam Mode</button>
    </div>

    <select id="cameraSelect" style="display: none;">
        <option value="">Loading cameras...</option>
    </select>

    <div id="fileInputContainer">
        <label for="videoFile">Choose a Video File:</label>
        <input type="file" id="videoFile" accept="video/*">
    </div>

    <div id="webcamContainer">
        <video id="webcamVideo" autoplay playsinline></video>
        <div id="liveDetection">No Accident Detected</div>
        <div class="recording-indicator" style="display: none;"></div>
        <button class="fullscreen-btn" id="fullscreenButton">
            <i class="fas fa-expand"></i>
            <i class="fas fa-compress"></i>
        </button>
        <div class="webcam-controls">
            <button id="actionButton">Start Detection</button>
        </div>
    </div>

    <div class="location-controls">
        <label>Location:</label>
        <div class="location-error" id="locationError" style="display: none;"></div>
        <input type="text" id="latitude" placeholder="Enter latitude">
        <input type="text" id="longitude" placeholder="Enter longitude">
        <button type="button" id="getLocationBtn">Get Current Location</button>
        <button type="button" id="defaultLocationBtn">Use Default Location</button>
    </div>
    
    <button type="button" id="uploadButton">Upload and Detect</button>
    
    <p id="result"></p>
    <div id="detectedFrames"></div>
    <p id="avgDetection"></p>

    <!-- Move best frames container inside the main container -->
    <div class="best-frames-container" id="bestFramesContainer" style="display: none;">
        <div class="frames-title">
            <h3>Best Accident Detections</h3>
            <div class="upload-info" id="uploadInfo">
                <span class="upload-spinner"></span>
                <span class="upload-text" id="uploadText">Not uploaded to Firestore</span>
            </div>
        </div>
        <div class="best-frames-grid" id="bestFramesGrid"></div>
    </div>
</div>

<script>
    // Update API base URL configuration
    function getApiBaseUrl() {
        // Get the current window location
        const currentLocation = window.location;
        const protocol = currentLocation.protocol;
        const hostname = currentLocation.hostname;
        
        // If we're running locally, use HTTPS and port 8080
        if (hostname === 'localhost' || hostname === '127.0.0.1') {
            return `https://${hostname}:8080`;
        }
        
        // For production/development server
        return `https://${hostname}:8080`;
    }

    const API_BASE_URL = getApiBaseUrl();
    console.log('Using API URL:', API_BASE_URL);

    // Add function to test server connection
    async function testServerConnection() {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout

            const response = await fetch(`${API_BASE_URL}/health`, {
                method: 'GET',
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                throw new Error(`Server responded with status: ${response.status}`);
            }

            console.log('Server connection successful');
            return true;
        } catch (error) {
            console.error('Server connection test failed:', error);
            return false;
        }
    }

    let currentMode = 'file';
    let mediaRecorder = null;
    let recordedChunks = [];
    let webcamStream = null;
    let isRecording = false;
    let recordingStartTime = null;
    let processingInterval = null;
    let lastProcessedTime = 0;
    let frameBuffer = [];
    let pendingProcessing = false;
    const PROCESS_INTERVAL = 1000;
    const WINDOW_SIZE = 3000;
    const DEFAULT_LATITUDE = 13.0827;  // Default latitude for Chennai
    const DEFAULT_LONGITUDE = 80.2707; // Default longitude for Chennai

    // Add heap for storing best frames
    let bestFramesHeap = [];
    let totalDetections = 0;
    let processedFrames = 0;

    // Add these variables at the top with other global variables
    let collectedFrames = [];
    let frameTimestamps = [];

    // Helper function to maintain heap of best frames
    function addToBestFrames(confidence, frame, isAccident, timestamp) {
        // Only add to heap if it's an accident frame
        if (isAccident) {
            // Add new frame with confidence and timestamp
            bestFramesHeap.push({
                confidence: confidence,
                frame: frame,
                timestamp: timestamp
            });
            
            // Sort in descending order of confidence
            bestFramesHeap.sort((a, b) => b.confidence - a.confidence);
            
            // Keep only top 3 frames
            if (bestFramesHeap.length > 3) {
                bestFramesHeap.pop();
            }

            // Show the container and update display
            const container = document.getElementById('bestFramesContainer');
            if (container) {
                container.style.display = 'block';
                updateBestFramesDisplay();
            }
        }
    }

    // Function to update the best frames display
    function updateBestFramesDisplay() {
        const container = document.getElementById('bestFramesContainer');
        const grid = document.getElementById('bestFramesGrid');
        
        // Show the container if we have frames
        container.style.display = bestFramesHeap.length > 0 ? 'block' : 'none';
        
        // Clear existing frames
        grid.innerHTML = '';
        
        if (bestFramesHeap.length === 0) {
            grid.innerHTML = '<div class="no-frames-message">No accident frames detected yet</div>';
            return;
        }
        
        // Add each frame to the grid
        bestFramesHeap.forEach((item, index) => {
            const frameCard = document.createElement('div');
            frameCard.className = 'frame-card';
            
            frameCard.innerHTML = `
                <div class="frame-rank">${index + 1}</div>
                <div class="frame-info">
                    Confidence: ${(item.confidence * 100).toFixed(1)}%
                </div>
                <img src="data:image/jpeg;base64,${item.frame}" 
                     alt="Accident Detection ${index + 1}"
                     loading="lazy">
            `;
            
            grid.appendChild(frameCard);
        });
    }

    // Add function to get location
    function getLocation() {
        if (navigator.geolocation) {
            document.getElementById('locationError').style.display = 'none';
            navigator.geolocation.getCurrentPosition(
                position => {
                    document.getElementById("latitude").value = position.coords.latitude;
                    document.getElementById("longitude").value = position.coords.longitude;
                    document.getElementById('locationError').style.display = 'none';
                },
                error => {
                    let errorMessage = "Failed to retrieve location: ";
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage += "Location permission denied. Please allow location access or enter coordinates manually.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage += "Location information unavailable. Please try again or enter coordinates manually.";
                            break;
                        case error.TIMEOUT:
                            errorMessage += "Location request timed out. Please try again or enter coordinates manually.";
                            break;
                        default:
                            errorMessage += "An unknown error occurred. Please try again or enter coordinates manually.";
                    }
                    document.getElementById('locationError').textContent = errorMessage;
                    document.getElementById('locationError').style.display = 'block';
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        } else {
            document.getElementById('locationError').textContent = 
                "Geolocation is not supported by this browser. Please enter coordinates manually.";
            document.getElementById('locationError').style.display = 'block';
        }
    }

    // Add function to use default location
    function useDefaultLocation() {
        document.getElementById('latitude').value = DEFAULT_LATITUDE;
        document.getElementById('longitude').value = DEFAULT_LONGITUDE;
        document.getElementById('locationError').style.display = 'none';
    }

    // Try to get location when page loads
    window.addEventListener('load', () => {
        getLocation();
        checkWebcamSupport();
        // If location is not set after 2 seconds, use default location
        setTimeout(() => {
            if (!document.getElementById('latitude').value || 
                !document.getElementById('longitude').value) {
                useDefaultLocation();
            }
        }, 2000);
    });

    // Validate coordinates before submitting
    function validateCoordinates() {
        const lat = parseFloat(document.getElementById('latitude').value);
        const lng = parseFloat(document.getElementById('longitude').value);
        
        if (isNaN(lat) || isNaN(lng) || 
            lat < -90 || lat > 90 || 
            lng < -180 || lng > 180) {
            document.getElementById('locationError').textContent = 
                "Invalid coordinates. Please enter valid latitude (-90 to 90) and longitude (-180 to 180).";
            document.getElementById('locationError').style.display = 'block';
            return false;
        }
        return true;
    }

    async function switchMode(mode) {
        currentMode = mode;
        document.getElementById('fileMode').classList.toggle('active', mode === 'file');
        document.getElementById('webcamMode').classList.toggle('active', mode === 'webcam');
        document.getElementById('fileInputContainer').style.display = mode === 'file' ? 'block' : 'none';
        document.getElementById('webcamContainer').style.display = mode === 'webcam' ? 'block' : 'none';
        document.getElementById('actionButton').innerText = mode === 'file' ? 'Upload and Detect' : 'Start Detection';

        if (mode === 'webcam') {
            try {
                // Check if we're on HTTPS or localhost
                if (location.protocol !== 'https:' && !location.hostname.includes('localhost') && !location.hostname.includes('127.0.0.1')) {
                    throw new Error('Webcam access requires HTTPS unless running on localhost. Please use HTTPS or access through localhost.');
                }

                // Check if mediaDevices is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Your browser does not support webcam access. Please try a modern browser like Chrome, Firefox, or Edge.');
                }

                // Initialize camera without starting recording
                await initializeCamera();
            } catch (err) {
                let errorMessage = 'Error accessing webcam: ';
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    errorMessage += 'Camera access was denied. Please allow camera access in your browser settings.';
                } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                    errorMessage += 'No camera found. Please make sure your camera is connected and not in use by another application.';
                } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                    errorMessage += 'Camera is in use by another application. Please close other applications using the camera.';
                } else if (err.message.includes('HTTPS')) {
                    errorMessage = err.message;
                } else {
                    errorMessage += err.message || 'Unknown error occurred.';
                }
                alert(errorMessage);
                // Switch back to file mode
                switchMode('file');
            }
        } else {
            stopWebcamRecording();
        }

        // Clear best frames display when switching modes
        const container = document.getElementById('bestFramesContainer');
        const grid = document.getElementById('bestFramesGrid');
        const uploadInfo = document.getElementById('uploadInfo');
        
        container.style.display = 'none';
        grid.innerHTML = '';
        uploadInfo.textContent = 'Not uploaded to Firestore';
        uploadInfo.style.backgroundColor = '';
        uploadInfo.style.color = '';
        
        bestFramesHeap = [];
    }

    async function initializeCamera() {
        const cameraSelect = document.getElementById('cameraSelect');
        let constraints = {
            video: {
                width: { ideal: 1280 },
                height: { ideal: 720 },
                frameRate: { ideal: 30 }
            }
        };

        // If a specific camera is selected
        if (cameraSelect.value) {
            constraints.video.deviceId = { exact: cameraSelect.value };
        } else {
            // Try to use back camera by default on mobile
            constraints.video.facingMode = { ideal: 'environment' };
        }

        // Stop any existing stream
        if (webcamStream) {
            webcamStream.getTracks().forEach(track => track.stop());
        }

        // Get new stream
        webcamStream = await navigator.mediaDevices.getUserMedia(constraints);
        const videoElement = document.getElementById('webcamVideo');
        videoElement.srcObject = webcamStream;
        await videoElement.play();
    }

    async function listCameras() {
        try {
            // First request permission
            await navigator.mediaDevices.getUserMedia({ video: true });
            
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');
            const cameraSelect = document.getElementById('cameraSelect');
            cameraSelect.innerHTML = ''; // Clear existing options

            if (videoDevices.length > 0) {
                cameraSelect.style.display = 'block';
                
                // Add a default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.text = 'Select Camera';
                cameraSelect.appendChild(defaultOption);
                
                // Add all available cameras
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    
                    // Try to identify camera type
                    const label = device.label.toLowerCase();
                    if (label.includes('back') || label.includes('rear') || label.includes('environment')) {
                        option.text = 'Back Camera';
                        option.dataset.isBack = 'true';
                    } else if (label.includes('front') || label.includes('user') || label.includes('face')) {
                        option.text = 'Front Camera';
                    } else {
                        option.text = `Camera ${index + 1}`;
                    }
                    
                    // If no label (before permission), use generic names
                    if (!device.label) {
                        option.text = index === 0 ? 'Front Camera' : 'Back Camera';
                        if (index === 1) option.dataset.isBack = 'true';
                    }
                    
                    cameraSelect.appendChild(option);
                });

                // Try to select back camera
                const backCamera = Array.from(cameraSelect.options).find(option => 
                    option.dataset.isBack === 'true' || 
                    option.text.includes('Back Camera')
                );
                
                if (backCamera) {
                    cameraSelect.value = backCamera.value;
                }
            } else {
                cameraSelect.style.display = 'none';
            }
        } catch (err) {
            console.error('Error listing cameras:', err);
        }
    }

    async function startWebcamRecording() {
        try {
            const cameraSelect = document.getElementById('cameraSelect');
            let constraints = {
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: 30 }
                }
            };

            // If a specific camera is selected
            if (cameraSelect.value) {
                constraints.video.deviceId = { exact: cameraSelect.value };
            } else {
                // Try to use back camera by default on mobile
                constraints.video.facingMode = { ideal: 'environment' };
            }

            // Stop any existing stream
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
            }

            // Get new stream
            webcamStream = await navigator.mediaDevices.getUserMedia(constraints);
            const videoElement = document.getElementById('webcamVideo');
            videoElement.srcObject = webcamStream;
            await videoElement.play();

            // Initialize recording variables
            recordedChunks = [];
            bestFramesHeap = [];
            totalDetections = 0;
            processedFrames = 0;
            isRecording = true;
            recordingStartTime = Date.now();

            // Set up MediaRecorder with high quality
            mediaRecorder = new MediaRecorder(webcamStream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 2500000 // 2.5 Mbps for good quality
            });

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            // Start recording
            mediaRecorder.start();
            
            // Show recording indicator
            document.querySelector('.recording-indicator').style.display = 'block';
            
            // Start frame processing
            processWebcamSegment();

        } catch (err) {
            console.error('Error starting recording:', err);
            alert('Error starting recording: ' + err.message);
        }
    }

    async function stopWebcamRecording() {
        if (!isRecording) {
            return;
        }
        
        isRecording = false;
        console.log("Stopping webcam recording...");
        
        // Stop media recorder and tracks
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            console.log("Stopping media recorder...");
            mediaRecorder.stop();
            await new Promise(resolve => mediaRecorder.onstop = resolve);
            console.log("Media recorder stopped");
        }
        
        // Create video blob from recorded chunks
        let videoBlob = null;
        if (recordedChunks.length > 0) {
            try {
                videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
                console.log("Created video blob:", videoBlob);
            } catch (error) {
                console.error("Error creating video blob:", error);
            }
        }
        
        if (webcamStream) {
            console.log("Stopping webcam stream...");
            webcamStream.getTracks().forEach(track => {
                track.stop();
                webcamStream.removeTrack(track);
            });
            webcamStream = null;
            console.log("Webcam stream stopped");
        }
        
        // Clear video source
        const videoElement = document.getElementById('webcamVideo');
        if (videoElement.srcObject) {
            videoElement.srcObject = null;
        }
        
        // Reset UI elements
        document.querySelector('.recording-indicator').style.display = 'none';
        document.getElementById('liveDetection').innerText = 'Processing complete';
        
        // If we have accident detections, upload to Firestore
        if (bestFramesHeap.length > 0 && videoBlob) {
            console.log(`Found ${bestFramesHeap.length} best frames to upload`);
            
            // Update upload status UI
            let uploadInfo = document.getElementById('uploadInfo');
            let uploadText = document.getElementById('uploadText');
            let spinner = uploadInfo?.querySelector('.upload-spinner');
            
            if (uploadInfo && uploadText) {
                uploadInfo.className = 'upload-info uploading';
                uploadText.textContent = 'Uploading to Firestore...';
                if (spinner) {
                    spinner.style.display = 'inline-block';
                }
            }
            
            try {
                console.log("Preparing data for upload...");
                
                // Create FormData with video and best frames
                const formData = new FormData();
                formData.append("video_data", videoBlob, "recorded-video.webm");
                formData.append("best_frames", JSON.stringify(bestFramesHeap));
                formData.append("latitude", document.getElementById("latitude").value);
                formData.append("longitude", document.getElementById("longitude").value);
                
                // Send to server
                const response = await fetch(`${API_BASE_URL}/stop_webcam`, {
                    method: "POST",
                    body: formData
                });
                
                const responseData = await response.json();
                console.log("Server response:", responseData);
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${JSON.stringify(responseData)}`);
                }
                
                // Update upload status
                if (uploadInfo && uploadText) {
                    uploadInfo.className = 'upload-info success';
                    uploadText.textContent = 'Successfully uploaded to Firestore';
                    if (spinner) {
                        spinner.style.display = 'none';
                    }
                }
                
                console.log("Upload completed successfully");
                
            } catch (error) {
                console.error('Error uploading data:', error);
                if (uploadInfo && uploadText) {
                    uploadInfo.className = 'upload-info error';
                    uploadText.textContent = 'Failed to upload to Firestore';
                    if (spinner) {
                        spinner.style.display = 'none';
                    }
                }
            }
        } else {
            console.log("No accident frames to upload");
            document.getElementById('bestFramesContainer').style.display = 'none';
        }
        
        // Reset recording variables
        console.log("Resetting recording variables...");
        recordedChunks = [];
        bestFramesHeap = [];
        totalDetections = 0;
        processedFrames = 0;
        collectedFrames = [];
        
        console.log("Webcam recording cleanup completed");
    }

    async function processWebcamSegment() {
        if (!isRecording || !validateCoordinates()) {
            return;
        }

        const currentTimestamp = Date.now() - recordingStartTime;
        const video = document.getElementById('webcamVideo');
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        try {
            // Convert canvas to blob
            const imageBlob = await new Promise(resolve => {
                canvas.toBlob(resolve, 'image/jpeg', 0.95);
            });

            // Create accident data object with properly formatted timestamp
            const now = new Date();
            const formattedTimestamp = now.toISOString();
            const accidentData = {
                location: {
                    latitude: parseFloat(document.getElementById("latitude").value),
                    longitude: parseFloat(document.getElementById("longitude").value)
                },
                timestamp: formattedTimestamp,
                metadata: {
                    source_type: "webcam",
                    processed_at: formattedTimestamp
                }
            };

            // Create FormData and append frame
            const formData = new FormData();
            formData.append("file", imageBlob, "frame.jpg");
            formData.append("source_type", "webcam");
            formData.append("accident_data", JSON.stringify(accidentData));

            // Send frame for processing
            const response = await fetch(`${API_BASE_URL}/predict`, {
                method: "POST",
                body: formData
            });

            const result = await response.json();

            if (result.status === "success") {
                // Update live detection status
                const liveDetection = document.getElementById('liveDetection');
                if (result.label === "Accident") {
                    liveDetection.innerText = `Accident Detected (${(result.confidence * 100).toFixed(1)}%)`;
                    liveDetection.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
                    
                    // Store frame data for best frames with proper timestamp
                    const frameData = {
                        frame: result.frame,
                        confidence: result.confidence,
                        timestamp: formattedTimestamp
                    };
                    
                    // Add to best frames if it's one of the top 3
                    addToBestFrames(result.confidence, result.frame, true, formattedTimestamp);
                } else {
                    liveDetection.innerText = 'No Accident Detected';
                    liveDetection.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                }

                // Store frame for video with proper timestamp
                if (result.frame) {
                    collectedFrames.push({
                        frame: result.frame,
                        timestamp: formattedTimestamp,
                        isAccident: result.label === "Accident",
                        confidence: result.confidence
                    });
                }
            }

            processedFrames++;

        } catch (error) {
            console.error('Error processing frame:', error);
        }

        // Continue processing if still recording
        if (isRecording) {
            requestAnimationFrame(processWebcamSegment);
        }
    }

    async function processCollectedFrames() {
        console.log("Processing collected frames...");
        const resultElement = document.getElementById('liveDetection');
        bestFramesHeap = [];
        totalDetections = 0;

        // Process each frame
        for (let i = 0; i < collectedFrames.length; i++) {
            const frameData = collectedFrames[i];
            
            try {
                // Create accident data object
                const accidentData = {
                    location: {
                        latitude: parseFloat(document.getElementById("latitude").value),
                        longitude: parseFloat(document.getElementById("longitude").value)
                    },
                    timestamp: new Date().toISOString(),
                    metadata: {
                        source_type: "webcam",
                        processed_at: new Date().toISOString()
                    }
                };

                const formData = new FormData();
                formData.append("file", frameData.blob, "webcam-frame.jpg");
                formData.append("source_type", "webcam");
                formData.append("accident_data", JSON.stringify(accidentData));

                const response = await fetch(`${API_BASE_URL}/predict`, {
                    method: "POST",
                    body: formData,
                });

                const result = await response.json();
                
                if (result.label === 'Accident') {
                    totalDetections += (result.frames.length || 1);
                    // Add each detected frame to the heap
                    for (let j = 0; j < result.frames.length; j++) {
                        addToBestFrames(
                            result.confidences[j], 
                            frameData.frame,  // Use original frame
                            true, 
                            frameData.timestamp
                        );
                    }
                }

                // Update progress
                resultElement.innerText = `Processing: ${Math.round((i + 1) * 100 / collectedFrames.length)}%`;

            } catch (error) {
                console.error('Error processing frame:', error);
            }
        }

        // Clear the frames after processing
        collectedFrames = [];
        console.log("Frame processing completed");
        resultElement.innerText = 'Processing Complete';
    }

    async function uploadVideo() {
        if (!validateCoordinates()) {
            return;
        }

        const fileInput = document.getElementById("videoFile");
        const file = fileInput.files[0];
        const resultElement = document.getElementById("result");
        const uploadButton = document.getElementById("uploadButton");
        
        if (!file) {
            resultElement.innerHTML = `
                <div style="color: #dc3545; padding: 10px; border-radius: 4px; background-color: #f8d7da;">
                    Please select a video file.
                </div>`;
            return;
        }

        // Disable the upload button while processing
        uploadButton.disabled = true;

        // Create processing status element if it doesn't exist
        let statusElement = document.getElementById('processingStatus');
        if (!statusElement) {
            statusElement = document.createElement('div');
            statusElement.id = 'processingStatus';
            statusElement.className = 'processing-status animated';
            uploadButton.parentNode.insertBefore(statusElement, uploadButton.nextSibling);
        }

        const updateStatus = (message, isError = false) => {
            console.log('Status update:', message);
            statusElement.innerHTML = `
                <div class="upload-spinner"></div>
                <span>${message}</span>
            `;
            statusElement.style.display = 'flex';
            statusElement.style.backgroundColor = isError ? '#f8d7da' : '#fff3cd';
            statusElement.style.color = isError ? '#721c24' : '#856404';
        };

        // Update upload button style
        uploadButton.innerHTML = `
            <div class="upload-button-content">
                <div class="upload-spinner"></div>
                <span>Processing...</span>
            </div>
        `;

        try {
            // Check file size (limit to 100MB)
            const maxSize = 100 * 1024 * 1024;
            if (file.size > maxSize) {
                throw new Error('File size too large. Please select a video file smaller than 100MB.');
            }

            updateStatus('Testing server connection...');
            const isServerAvailable = await testServerConnection();
            if (!isServerAvailable) {
                throw new Error('Cannot connect to server. Please check your connection and try again.');
            }

            // Create accident data object
            const accidentData = {
                location: {
                    latitude: parseFloat(document.getElementById("latitude").value),
                    longitude: parseFloat(document.getElementById("longitude").value)
                },
                timestamp: new Date().toISOString(),
                metadata: {
                    source_type: "file",
                    processed_at: new Date().toISOString(),
                    detection_model: "YOLOv8"
                }
            };

            const formData = new FormData();
            formData.append("file", file);
            formData.append("accident_data", JSON.stringify(accidentData));
            formData.append("source_type", "file");

            updateStatus('Uploading video file...');
            
            // Make the API call
            const response = await fetch(`${API_BASE_URL}/predict`, {
                method: "POST",
                body: formData
            });

            if (!response.ok) {
                throw new Error(`Upload failed with status: ${response.status}`);
            }

            // Set up SSE for status updates
            const eventSource = new EventSource(`${API_BASE_URL}/status`);
            
            eventSource.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.status) {
                    updateStatus(data.status);
                }
            };

            eventSource.onerror = () => {
                eventSource.close();
            };

            // Process the response
            const result = await response.json();
            console.log('API Response:', result);

            // Close SSE connection
            eventSource.close();

            // Handle the response
            if (result.status === 'success') {
                if (result.label === 'Accident Detected') {
                    updateStatus('Accident detected! Displaying results...');
                } else {
                    updateStatus('No accidents detected');
                }
                
                setTimeout(() => {
                    statusElement.style.display = 'none';
                    displayResults(result);
                }, 1000);
            } else {
                throw new Error(result.error || 'Unknown error occurred');
            }

        } catch (error) {
            console.error('Error:', error);
            updateStatus(error.message, true);
            
            document.getElementById("detectedFrames").innerHTML = '';
            document.getElementById("avgDetection").innerText = '';
            
        } finally {
            uploadButton.disabled = false;
            uploadButton.innerHTML = 'Upload and Detect';
        }
    }

    function displayResults(result) {
        console.log('Full API Response:', result);
        console.log('Frames:', result.frames);
        console.log('Frame URLs:', result.frame_urls);
        console.log('Detected Frames:', result.detected_frames);
        
        const resultElement = document.getElementById("result");
        const framesContainer = document.getElementById("detectedFrames");
        const avgDetectionElement = document.getElementById("avgDetection");
        const bestFramesContainer = document.getElementById("bestFramesContainer");
        const uploadInfo = document.getElementById('uploadInfo');
        const uploadText = document.getElementById('uploadText');
        
        // Clear previous results
        framesContainer.innerHTML = '';
        avgDetectionElement.innerText = '';
        bestFramesContainer.style.display = 'none';
        
        if (!result || result.status !== 'success') {
            resultElement.innerHTML = `
                <div style="padding: 15px; text-align: center; color: #6c757d; font-style: italic;">
                    ${result?.error || 'No accident frames detected'}
                </div>`;
            return;
        }

        const label = result.label || "Unknown";
        const isAccident = label === "Accident Detected";
        
        resultElement.innerHTML = `
            <div style="
                padding: 15px;
                border-radius: 8px;
                margin: 10px 0;
                text-align: center;
                font-size: 1.2em;
                font-weight: bold;
                background-color: ${isAccident ? '#f8d7da' : '#d4edda'};
                color: ${isAccident ? '#721c24' : '#155724'};
                border: 1px solid ${isAccident ? '#f5c6cb' : '#c3e6cb'};
            ">
                ${label}
            </div>`;
        
        if (typeof result.average_detection_percentage === 'number') {
            avgDetectionElement.innerHTML = `
                <div style="padding: 10px; border-radius: 4px; margin: 10px 0; background-color: #e9ecef; color: #495057;">
                    Average Detection: ${result.average_detection_percentage.toFixed(2)}%
                </div>`;
        }
        
        // Get frames and confidence values from accident_data
        const frames = result.frames || [];
        const confidences = [];
        const timestamps = [];
        
        // Extract confidence values and timestamps from accident_data
        if (result.accident_data && result.accident_data.detected_frames) {
            result.accident_data.detected_frames.forEach((frame, index) => {
                confidences[index] = frame.confidence;
                timestamps[index] = frame.timestamp;
            });
        }
        
        if (!frames || frames.length === 0) {
            framesContainer.innerHTML = `
                <div style="padding: 15px; text-align: center; color: #6c757d; font-style: italic;">
                    No accident frames detected
                </div>`;
            return;
        }
        
        if (isAccident) {
            bestFramesContainer.style.display = 'block';
            
            if (result.doc_id && result.video_url) {
                uploadInfo.className = 'upload-info success';
                uploadText.textContent = 'Successfully uploaded to Firestore';
                const spinner = uploadInfo.querySelector('.upload-spinner');
                if (spinner) spinner.style.display = 'none';
            } else {
                uploadInfo.className = 'upload-info error';
                uploadText.textContent = 'Not uploaded to Firestore';
                const spinner = uploadInfo.querySelector('.upload-spinner');
                if (spinner) spinner.style.display = 'none';
            }
        }
        
        const gridContainer = document.createElement('div');
        gridContainer.style.display = 'grid';
        gridContainer.style.gridTemplateColumns = 'repeat(auto-fit, minmax(300px, 1fr))';
        gridContainer.style.gap = '20px';
        gridContainer.style.padding = '20px';
        
        frames.forEach((frame, index) => {
            console.log(`Processing frame ${index}:`, {
                frame,
                confidence: confidences[index],
                timestamp: timestamps[index]
            });
            
            const frameDiv = document.createElement('div');
            frameDiv.style.position = 'relative';
            frameDiv.style.marginBottom = '20px';
            
            const img = document.createElement('img');
            img.src = frame; // Direct URL from frames array
            img.style.width = '100%';
            img.style.borderRadius = '8px';
            img.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
            
            img.onerror = function() {
                console.error('Error loading image:', frame);
                this.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjhmOWZhIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNHB4IiBmaWxsPSIjNmM3NTdkIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+SW1hZ2UgbG9hZCBlcnJvcjwvdGV4dD48L3N2Zz4=';
                this.style.opacity = '0.5';
            };
            
            const confidenceLabel = document.createElement('div');
            confidenceLabel.style.position = 'absolute';
            confidenceLabel.style.top = '10px';
            confidenceLabel.style.left = '10px';
            confidenceLabel.style.background = 'rgba(0,0,0,0.7)';
            confidenceLabel.style.color = 'white';
            confidenceLabel.style.padding = '5px 10px';
            confidenceLabel.style.borderRadius = '4px';
            
            // Get confidence value from confidences array
            let confidenceText = 'N/A';
            if (confidences[index] !== undefined && confidences[index] !== null) {
                const confidenceValue = parseFloat(confidences[index]);
                if (!isNaN(confidenceValue)) {
                    confidenceText = `${(confidenceValue * 100).toFixed(2)}%`;
                }
            }
            confidenceLabel.innerText = `Confidence: ${confidenceText}`;
            
            // Add timestamp if available
            if (timestamps[index]) {
                const timestampLabel = document.createElement('div');
                timestampLabel.style.position = 'absolute';
                timestampLabel.style.bottom = '10px';
                timestampLabel.style.left = '10px';
                timestampLabel.style.background = 'rgba(0,0,0,0.7)';
                timestampLabel.style.color = 'white';
                timestampLabel.style.padding = '5px 10px';
                timestampLabel.style.borderRadius = '4px';
                timestampLabel.style.fontSize = '0.8em';
                
                const date = new Date(timestamps[index]);
                timestampLabel.innerText = date.toLocaleTimeString();
                
                frameDiv.appendChild(timestampLabel);
            }
            
            frameDiv.appendChild(img);
            frameDiv.appendChild(confidenceLabel);
            gridContainer.appendChild(frameDiv);
        });
        
        framesContainer.appendChild(gridContainer);
    }

    // Modify camera selection change handler
    document.getElementById('cameraSelect').addEventListener('change', async () => {
        await initializeCamera();
    });

    // Modify checkWebcamSupport to include camera listing
    async function checkWebcamSupport() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            document.getElementById('webcamMode').style.display = 'none';
            const warning = document.createElement('div');
            warning.style.color = '#dc3545';
            warning.style.margin = '10px 0';
            warning.innerHTML = 'Webcam access is not supported in your current environment. This might be because:<br>' +
                              '1. You\'re not using HTTPS<br>' +
                              '2. Your browser doesn\'t support webcam access<br>' +
                              '3. You\'re using an unsupported device';
            document.querySelector('.input-mode').appendChild(warning);
        } else {
            try {
                // Request camera permission
                await navigator.mediaDevices.getUserMedia({ video: true });
                // List available cameras but keep the select hidden initially in file mode
                await listCameras();
                const cameraSelect = document.getElementById('cameraSelect');
                cameraSelect.style.display = currentMode === 'webcam' ? 'block' : 'none';
            } catch (err) {
                console.error('Error checking webcam support:', err);
            }
        }
    }

    async function handleAction() {
        if (currentMode === 'file') {
            await uploadVideo();
        } else {
            const actionButton = document.querySelector('.webcam-controls #actionButton');
            if (!isRecording) {
                // Start recording
                actionButton.innerText = 'Stop Detection';
                startWebcamRecording();
            } else {
                // Stop recording and disable button temporarily
                actionButton.disabled = true;
                actionButton.innerText = 'Processing...';
                await stopWebcamRecording();
                actionButton.innerText = 'Start Detection';
                actionButton.disabled = false;
            }
        }
    }

    // Add event listeners when the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Mode switching buttons
        const fileModeBtn = document.getElementById('fileMode');
        const webcamModeBtn = document.getElementById('webcamMode');
        const uploadBtn = document.getElementById('uploadButton');
        const actionBtn = document.querySelector('.webcam-controls #actionButton');
        const fullscreenBtn = document.getElementById('fullscreenButton');
        const fileInputContainer = document.getElementById('fileInputContainer');
        const webcamContainer = document.getElementById('webcamContainer');
        const cameraSelect = document.getElementById('cameraSelect');
        
        // Mode switching
        if (fileModeBtn) {
            fileModeBtn.addEventListener('click', () => {
                currentMode = 'file';
                fileModeBtn.classList.add('active');
                webcamModeBtn.classList.remove('active');
                fileInputContainer.style.display = 'block';
                webcamContainer.style.display = 'none';
                uploadBtn.style.display = 'block';
                cameraSelect.style.display = 'none';
                if (webcamStream) {
                    webcamStream.getTracks().forEach(track => track.stop());
                }
            });
        }
        
        if (webcamModeBtn) {
            webcamModeBtn.addEventListener('click', () => {
                currentMode = 'webcam';
                webcamModeBtn.classList.add('active');
                fileModeBtn.classList.remove('active');
                fileInputContainer.style.display = 'none';
                webcamContainer.style.display = 'block';
                uploadBtn.style.display = 'none';
                cameraSelect.style.display = 'block';
                initializeCamera();
            });
        }
        
        // Action buttons
        if (uploadBtn) {
            uploadBtn.addEventListener('click', async () => {
                if (currentMode === 'file') {
                    await uploadVideo();
                }
            });
        }
        
        if (actionBtn) {
            actionBtn.addEventListener('click', async () => {
                if (currentMode === 'webcam') {
                    await handleAction();
                }
            });
        }
        
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', toggleFullscreen);
        }
        
        // Location buttons
        const getLocationBtn = document.getElementById('getLocationBtn');
        const defaultLocationBtn = document.getElementById('defaultLocationBtn');
        if (getLocationBtn) getLocationBtn.addEventListener('click', getLocation);
        if (defaultLocationBtn) defaultLocationBtn.addEventListener('click', useDefaultLocation);
        
        // Initialize
        getLocation();
        checkWebcamSupport();
        
        // Default location fallback
        setTimeout(() => {
            if (!document.getElementById('latitude').value || 
                !document.getElementById('longitude').value) {
                useDefaultLocation();
            }
        }, 2000);
    });

    // Update fullscreen functions for better mobile support
    async function toggleFullscreen() {
        const container = document.getElementById('webcamContainer');
        const video = document.getElementById('webcamVideo');
        
        try {
            if (!document.fullscreenElement && 
                !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && 
                !document.msFullscreenElement) {
                
                // Enter fullscreen
                if (container.requestFullscreen) {
                    await container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    await container.webkitRequestFullscreen();
                } else if (container.mozRequestFullScreen) {
                    await container.mozRequestFullScreen();
                } else if (container.msRequestFullscreen) {
                    await container.msRequestFullscreen();
                }
                
                container.classList.add('fullscreen');
                
                // Try to lock orientation on mobile
                if (screen.orientation && screen.orientation.lock) {
                    try {
                        await screen.orientation.lock('landscape');
                    } catch (err) {
                        console.log('Orientation lock failed:', err);
                    }
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    await document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    await document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    await document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    await document.msExitFullscreen();
                }
                
                container.classList.remove('fullscreen');
                
                // Unlock orientation
                if (screen.orientation && screen.orientation.unlock) {
                    try {
                        await screen.orientation.unlock();
                    } catch (err) {
                        console.log('Orientation unlock failed:', err);
                    }
                }
            }
            
            // Update video size after fullscreen change
            updateVideoSize();
            
        } catch (err) {
            console.error('Fullscreen toggle failed:', err);
            // Force exit fullscreen if there's an error
            try {
                container.classList.remove('fullscreen');
                if (document.exitFullscreen) {
                    await document.exitFullscreen();
                }
            } catch (e) {
                console.error('Force exit fullscreen failed:', e);
            }
        }
    }

    // Update video sizing function
    function updateVideoSize() {
        const video = document.getElementById('webcamVideo');
        const container = document.getElementById('webcamContainer');
        
        if (container.classList.contains('fullscreen')) {
            const isLandscape = window.matchMedia("(orientation: landscape)").matches;
            video.style.width = '100%';
            video.style.height = isLandscape ? '100%' : 'auto';
            video.style.maxHeight = '100vh';
            
            // Ensure controls are visible in fullscreen
            document.querySelector('.webcam-controls').style.opacity = '1';
            document.querySelector('.fullscreen-btn').style.opacity = '1';
        } else {
            video.style.width = '100%';
            video.style.height = 'auto';
            video.style.maxHeight = '';
        }
    }

    // Add orientation change handler
    window.addEventListener('orientationchange', function() {
        setTimeout(updateVideoSize, 100);
    });

    // Add resize handler
    window.addEventListener('resize', function() {
        updateVideoSize();
    });

    // Add fullscreen change event listeners
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleFullscreenChange);

    function handleFullscreenChange() {
        const container = document.getElementById('webcamContainer');
        if (!document.fullscreenElement && 
            !document.webkitFullscreenElement && 
            !document.mozFullScreenElement && 
            !document.msFullscreenElement) {
            container.classList.remove('fullscreen');
        }
        updateVideoSize();
    }

    // Add new function to extract video clip
    async function extractClip() {
        try {
            // Create a blob from all recorded chunks
            const fullVideo = new Blob(mediaChunks, { type: 'video/webm' });
            
            // Convert video to ArrayBuffer
            const arrayBuffer = await fullVideo.arrayBuffer();
            
            // Convert to base64
            const base64Video = btoa(
                new Uint8Array(arrayBuffer)
                .reduce((data, byte) => data + String.fromCharCode(byte), '')
            );
            
            return base64Video;
        } catch (error) {
            console.error('Error extracting clip:', error);
        }
    }

    // Update the status message
    function updateStatus(message) {
        document.getElementById('status').textContent = message;
    }

    // Function to display frames
    function displayFrames(frames) {
        const framesContainer = document.getElementById('detectedFrames');
        framesContainer.innerHTML = ''; // Clear previous frames
        
        frames.forEach((frame, index) => {
            const img = document.createElement('img');
            // Remove any base64 prefix if present
            const cleanUrl = frame.replace(/^data:image\/jpeg;base64,/, '');
            img.src = cleanUrl;
            img.alt = `Detected Frame ${index + 1}`;
            img.className = 'detected-frame';
            img.onerror = function() {
                console.error('Error loading image:', cleanUrl);
                this.src = 'placeholder.jpg'; // Optional: show a placeholder for failed images
            };
            framesContainer.appendChild(img);
        });
    }

    // Handle file upload and prediction
    async function handleFileUpload() {
        const fileInput = document.getElementById('fileInput');
        const file = fileInput.files[0];
        if (!file) {
            alert('Please select a file first');
            return;
        }

        const formData = new FormData();
        formData.append('file', file);

        try {
            updateStatus('Uploading video file...');
            
            const response = await fetch('/predict', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            console.log('Response from server:', result); // Debug log

            // Check for errors
            if (result.error) {
                updateStatus(`Error: ${result.message}`);
                return;
            }

            // Update status based on detection result
            if (result.label === "Accident Detected") {
                updateStatus('Accident detected! Displaying results...');
                
                // Get frames from the correct location in the response
                let framesToDisplay = [];
                if (result.accident_data && result.accident_data.detected_frames) {
                    framesToDisplay = result.accident_data.detected_frames.map(frame => frame.image_url);
                }
                
                // Display frames
                displayFrames(framesToDisplay);

                // Display detection percentage
                document.getElementById('detectionPercentage').textContent = 
                    `Detection Percentage: ${result.average_detection_percentage}%`;

                // Display video URL if available
                if (result.video_url) {
                    const videoElement = document.getElementById('videoPlayer');
                    videoElement.src = result.video_url;
                    videoElement.style.display = 'block';
                }
            } else {
                updateStatus('No accidents detected in the video.');
                document.getElementById('detectedFrames').innerHTML = '';
                document.getElementById('detectionPercentage').textContent = '';
            }

        } catch (error) {
            console.error('Error:', error);
            updateStatus(`Error processing video: ${error.message}`);
        }
    }
</script>
</body>
</html>